package com.wilson.wdrip.utils;

import android.content.Context;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.graphics.DashPathEffect;
import android.preference.PreferenceManager;
import android.support.annotation.NonNull;
import android.text.format.DateFormat;
import android.util.Log;

import com.rits.cloning.Cloner;
import com.wilson.wdrip.Models.JoH;
import com.wilson.wdrip.data.BasalWatchData;
import com.wilson.wdrip.data.BgWatchData;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.TimeZone;

import lecho.lib.hellocharts.model.Axis;
import lecho.lib.hellocharts.model.AxisValue;
import lecho.lib.hellocharts.model.Line;
import lecho.lib.hellocharts.model.LineChartData;
import lecho.lib.hellocharts.model.PointValue;
import lecho.lib.hellocharts.model.Viewport;
import lecho.lib.hellocharts.view.Chart;

/**
 * Created by emmablack on 11/15/14.
 */
public class BgGraphBuilder {
    public static final int FUZZER = (1000 * 60);
    public double end_time = (new Date().getTime() + (60000 * 10)) / FUZZER;
    public double start_time = end_time - ((60000 * 60 * 24)) / FUZZER;
    private static final int NUM_VALUES = (60 / 5) * 24;

    public Context context;

    public double highMark = 9;
    public double lowMark = 5.2;
    public double defaultMinY = 2;
    public double defaultMaxY = 13;

    public Viewport viewport;

    public BgGraphBuilder(Context context) {
        this.context = context;
    }

    public LineChartData lineData() {
        LineChartData lineData = new LineChartData(defaultLines());
        lineData.setAxisYLeft(yAxis());
        lineData.setAxisXBottom(chartXAxis());
        return lineData;
    }

    public synchronized List<Line> defaultLines() {
        List<Line> lines = new ArrayList<Line>();

        lines.add(minShowLine());
        lines.add(maxShowLine());
        lines.add(highLine());
        lines.add(lowLine());

        return lines;
    }


    public LineChartData previewLineData(LineChartData hint) {

        LineChartData previewLineData;
        if (hint == null) {
            previewLineData = new LineChartData(lineData());
        } else {
            Cloner cloner = new Cloner();
            // cloner.setDumpClonedClasses(true);
            cloner.dontClone(
                    lecho.lib.hellocharts.model.PointValue.class,
                    lecho.lib.hellocharts.formatter.SimpleLineChartValueFormatter.class,
                    lecho.lib.hellocharts.model.Axis.class,
                    android.graphics.DashPathEffect.class);
            previewLineData = cloner.deepClone(hint);
        }

        previewLineData.setAxisYLeft(yAxis());
        previewLineData.setAxisXBottom(previewXAxis());
        // needs more adjustments - foreach
        return previewLineData;
    }

    public Line maxShowLine() {
        List<PointValue> maxShowValues = new ArrayList<PointValue>();
        maxShowValues.add(new PointValue((float) start_time, (float) defaultMaxY));
        maxShowValues.add(new PointValue((float) end_time, (float) defaultMaxY));
        Line maxShowLine = new Line(maxShowValues);
        maxShowLine.setHasLines(false);
        maxShowLine.setHasPoints(false);
        return maxShowLine;
    }

    public Line minShowLine() {
        List<PointValue> minShowValues = new ArrayList<PointValue>();
        minShowValues.add(new PointValue((float) start_time, (float) defaultMinY));
        minShowValues.add(new PointValue((float) end_time, (float) defaultMinY));
        Line minShowLine = new Line(minShowValues);
        minShowLine.setHasPoints(false);
        minShowLine.setHasLines(false);
        return minShowLine;
    }

    public Line highLine() {
        List<PointValue> highLineValues = new ArrayList<PointValue>();
        highLineValues.add(new PointValue((float) start_time, (float) highMark));
        highLineValues.add(new PointValue((float) end_time, (float) highMark));
        Line highLine = new Line(highLineValues);
        highLine.setHasPoints(false);
        highLine.setStrokeWidth(1);
        highLine.setColor(Color.YELLOW);
        return highLine;
    }

    public Line lowLine() {
        List<PointValue> lowLineValues = new ArrayList<PointValue>();
        lowLineValues.add(new PointValue((float) start_time, (float) lowMark));
        lowLineValues.add(new PointValue((float) end_time, (float) lowMark));
        Line lowLine = new Line(lowLineValues);
        lowLine.setHasPoints(false);
        lowLine.setAreaTransparency(50);
        lowLine.setColor(Color.RED);
        lowLine.setStrokeWidth(1);
        lowLine.setFilled(true);
        return lowLine;
    }

    /////////AXIS RELATED//////////////
    public Axis yAxis() {
        Axis yAxis = new Axis();
        yAxis.setAutoGenerated(false);
        List<AxisValue> axisValues = new ArrayList<AxisValue>();

        for (int j = 1; j <= 12; j += 1) {
            axisValues.add(new AxisValue(j * 2));
        }
        yAxis.setValues(axisValues);
        yAxis.setMaxLabelChars(5);
        yAxis.setInside(true);
        yAxis.setHasLines(true);
        return yAxis;
    }

    @NonNull
    public Axis xAxis() {
        Axis xAxis = new Axis();
        xAxis.setAutoGenerated(false);
        List<AxisValue> xAxisValues = new ArrayList<AxisValue>();


        final java.text.DateFormat timeFormat = hourFormat();
        timeFormat.setTimeZone(TimeZone.getDefault());

        GregorianCalendar calendar = new GregorianCalendar();
        calendar.setTimeInMillis((long)(start_time * FUZZER));
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        if (calendar.getTimeInMillis()<(start_time * FUZZER)){
            calendar.add(Calendar.HOUR, 1);
        }
        while (calendar.getTimeInMillis()< ( (end_time * FUZZER) + (1 * 60 * 60 * 1000))) {
            xAxisValues.add(new AxisValue((calendar.getTimeInMillis() / FUZZER), (timeFormat.format(calendar.getTimeInMillis())).toCharArray()));
            calendar.add(Calendar.HOUR, 1);
        }

        xAxis.setValues(xAxisValues);
        return xAxis;
    }

    public Axis chartXAxis() {
        Axis xAxis = xAxis();
        xAxis.setHasLines(true);
        xAxis.setTextSize(12);
        return xAxis;
    }

    public Axis previewXAxis(){
        Axis previewXaxis = xAxis();
        previewXaxis.setTextSize(5);
        previewXaxis.setHasLines(true);
        return previewXaxis;
    }

    private SimpleDateFormat hourFormat() {
        return new SimpleDateFormat(DateFormat.is24HourFormat(context) ? "HH" : "h a");
    }

    public Viewport advanceViewport(Chart chart, Chart previewChart) {
        viewport = new Viewport(previewChart.getMaximumViewport());
        viewport.inset((float) ((86400000 / 2.5f) / FUZZER), 0);
        double distance_to_move = ((new Date().getTime()) / FUZZER) - viewport.left - (((viewport.right - viewport.left) / 2));
        viewport.offset((float) distance_to_move, 0);
        return viewport;
    }
}
